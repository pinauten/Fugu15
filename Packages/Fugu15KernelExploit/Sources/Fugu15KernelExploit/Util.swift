import SwiftUtils
import CBindings

public enum JailbreakdError: Error {
    case custom(_: String)
}

public func execCmd(args: [String], fileActions: posix_spawn_file_actions_t? = nil) -> Int32? {
    var fileActions = fileActions
    
    var attr: posix_spawnattr_t?
    posix_spawnattr_init(&attr)
    posix_spawnattr_set_persona_np(&attr, 99, 1)
    posix_spawnattr_set_persona_uid_np(&attr, 0)
    posix_spawnattr_set_persona_gid_np(&attr, 0)
    
    var pid: pid_t = 0
    var argv: [UnsafeMutablePointer<CChar>?] = []
    for arg in args {
        argv.append(strdup(arg))
    }
    
    argv.append(nil)
    
    let result = posix_spawn(&pid, argv[0], &fileActions, &attr, &argv, environ)
    let err = errno
    guard result == 0 else {
        NSLog("Failed")
        NSLog("Error: \(result) Errno: \(err)")
        
        return nil
    }
    
    var status: Int32 = 0
    waitpid(pid, &status, 0)
    
    return status
}

var dpUserDefaults: UserDefaults? = nil
public func dopamineDefaults() -> UserDefaults {
    if dpUserDefaults == nil {
        let dopamineDefaultsPath = String(cString: getenv("HOME")) + "/Library/Preferences/com.opa334.Dopamine.plist"
        dpUserDefaults = UserDefaults.init(suiteName: dopamineDefaultsPath)
        dpUserDefaults!.register(defaults: [
            "tweakInjectionEnabled": true,
        ])
    }
    return dpUserDefaults!
}

public func handleWifiFixBeforeJailbreak(logger: (String) -> Void) {
    if #available(iOS 15.4, *) {
        // No Wifi fixup needed
    }
    else {
        let wifiEnabled = wifiIsEnabled()
        let enableWifiMarkerPath = String(cString: getenv("HOME")) + "/Library/Preferences/com.opa334.Dopamine.enable-wifi"
        if wifiEnabled {
            if !FileManager.default.fileExists(atPath: enableWifiMarkerPath) {
                try? "".write(toFile: enableWifiMarkerPath, atomically: false, encoding: String.Encoding.utf8)
            }
            logger("Disabling Wi-Fi")
            setWifiEnabled(false)
            sleep(5)
        }
    }
}

public func handleWifiFixAfterJailbreak(logger: (String) -> Void) {
    if #available(iOS 15.4, *) {
        // No Wifi fixup needed
    }
    else {
        let wifiEnabled = wifiIsEnabled()
        let enableWifiMarkerPath = String(cString: getenv("HOME")) + "/Library/Preferences/com.opa334.Dopamine.enable-wifi"
        if FileManager.default.fileExists(atPath: enableWifiMarkerPath) {
            try? FileManager.default.removeItem(atPath: enableWifiMarkerPath)
            if !wifiEnabled {
                logger("Enabling Wi-Fi")
                setWifiEnabled(true)
            }
        }
    }
}

public func updateTweakInjectionPreference() throws {
    let dpDefaults = dopamineDefaults()
    let tweakInjectionEnabled = dpDefaults.bool(forKey: "tweakInjectionEnabled")

    let safeModePath = prebootPath("basebin/.safe_mode")
    let safeModeState = FileManager.default.fileExists(atPath: safeModePath!)
    if tweakInjectionEnabled {
        if safeModeState {
            try FileManager.default.removeItem(atPath: safeModePath!)
        }
    }
    else {
        if !safeModeState {
            try "".write(toFile: safeModePath!, atomically: false, encoding: String.Encoding.utf8)
        }
    }
}

public func writeBootInfo(value: Any, forKey key: String) {
    let dict = NSMutableDictionary(contentsOfFile: prebootPath("basebin/boot_info.plist"))!
    dict.setObject(value, forKey: key as NSCopying)
    dict.write(toFile: prebootPath("basebin/boot_info.plist"), atomically: true)
}

func tcload(tcPath: String, krw: KRWHandler, slide: UInt64) throws -> UInt64 {
    guard let data = try? Data(contentsOf: URL(fileURLWithPath: tcPath)) else {
        throw JailbreakError.custom("Failed to read trust cache!")
    }
    
    // Make sure the trust cache is good
    guard data.count >= 0x18 else {
        throw JailbreakError.custom("Trust cache is too small!")
    }
    
    let vers = data.getGeneric(type: UInt32.self)
    guard vers == 1 else {
        throw JailbreakError.custom(String(format: "Trust cache has bad version (must be 1, is %u)!", vers))
    }
    
    let count = data.getGeneric(type: UInt32.self, offset: 0x14)
    guard data.count == 0x18 + (Int(count) * 22) else {
        throw JailbreakError.custom(String(format: "Trust cache has bad length (should be %p, is %p)!", 0x18 + (Int(count) * 22), data.count))
    }
    
    guard let pmap_image4_trust_caches = Fugu15.patchfinder?.pmap_image4_trust_caches else {
        throw JailbreakError.custom("Failed to patchfind pmap_image4_trust_caches!")
    }
    
    var mem: UInt64!
    do {
        mem = try krw.kalloc(size: UInt(data.count + 0x10))
    } catch let e {
        throw KRWError.customError(description: "Failed to allocate kernel memory for TrustCache: \(e)")
    }
    
    let next = KRWAddress(address: mem, options: [])
    let us   = KRWAddress(address: mem + 0x8, options: [])
    let tc   = KRWAddress(address: mem + 0x10, options: [])
    
    do {
        try krw.kwrite(address: us, data: Data(fromObject: mem + 0x10))
        try krw.kwrite(address: tc, data: data)
    } catch let e {
        throw KRWError.customError(description: "Failed to write to our TrustCache: \(e)")
    }
    
    let pitc = KRWAddress(address: pmap_image4_trust_caches + slide, options: .PPL)
    
    // Read head
    guard let cur = krw.r64(pitc) else {
        throw KRWError.customError(description: "Failed to read TrustCache head!")
    }
    
    // Write into our list entry
    try krw.kwrite(address: next, data: Data(fromObject: cur))
    
    // Replace head
    try krw.kwrite(address: pitc, data: Data(fromObject: mem.unsafelyUnwrapped))

    return mem
}

func startJailbreakd() throws {
    var KcallStatus = 0 as UInt64, PPLRWStatus = 0 as UInt64, jbdPid = 0 as pid_t
    jbdGetStatus(&PPLRWStatus, &KcallStatus, &jbdPid)
    if jbdPid == 0 {
        Logger.print(String(format:"Starting jailbreakd..."))
        _ = execCmd(args: [prebootPath("basebin/jbinit")])
        jbdGetStatus(&PPLRWStatus, &KcallStatus, &jbdPid)
    }

    if jbdPid == 0 {
        throw JailbreakdError.custom("Something went wrong when starting jailbreakd")
    }

    Logger.print(String(format:"Got jailbreakd pid: \(jbdPid)"))

    if PPLRWStatus == 0 {
        Logger.print(String(format:"Sending PPL primitives to jailbreakd..."))
        let rsp = Fugu15.oobPCIRequest(id: 7, addrPid: UInt64(jbdPid))
        jbdTransferPPLRW()
        jbdGetStatus(&PPLRWStatus, &KcallStatus, &jbdPid)
        if PPLRWStatus == 1 {
            Logger.print(String(format:"Initialized PPL primitives inside jailbreakd!"))
        }
        else {
            throw JailbreakdError.custom("Failed to initialize PPL primitives inside jailbreakd")
        }
    }

    if KcallStatus == 0 {
        Logger.print(String(format:"Sending PAC primitives to jailbreakd"))
        let threadToSign = jbdTransferKcall()
        jbdGetStatus(&PPLRWStatus, &KcallStatus, &jbdPid)
        if KcallStatus == 1 {
            Logger.print(String(format:"Got thread to sign: 0x\(String(threadToSign, radix: 16, uppercase: true))"))
            _ = Fugu15.oobPCIRequest(id: 8, addrPid: threadToSign)
            jbdFinalizeKcall()
            jbdGetStatus(&PPLRWStatus, &KcallStatus, &jbdPid)
            if KcallStatus == 2 {
                Logger.print(String(format:"Initialized PAC primitives inside jailbreakd!"))
            }
            else {
                throw JailbreakdError.custom("Failed to finalize PAC primitives inside jailbreakd")
            }
        }
        else {
            throw JailbreakdError.custom("Failed to prepare PAC primitives inside jailbreakd")
        }
    }
}
