//
//  SpawnDrv.swift
//  Fugu15KernelExploit/SpawnDrv
//
//  Created by Linus Henze.
//  Copyright Â© 2022 Pinauten GmbH. All rights reserved.
//

import Foundation
import Darwin
import SwiftUtils
import CBindings
import MachO
import SwiftMachO
import PatchfinderUtils
import KernelPatchfinder

let POSIX_SPAWN_PROC_TYPE_DRIVER: Int32 = 0x700

let BP_ENABLED: UInt64 = 1
let BP_USER:    UInt64 = 0b10   << 1
let BP_BAS:     UInt64 = 0b0011 << 5

enum SpawnDriverError: Error {
    case failedToOpenDriver
    case notADriver
    case posix_spawnattr_initFailed
    case posix_spawnFailed(error: Int32, string: String)
    case task_for_pidFailed
    case mach_port_allocateFailed
    case mach_port_insert_rightFailed
    case task_set_exception_portsFailed
}

typealias SpawnDrvExceptionHandler = (_: SpawnDrv, _: Task, _: Thread, _: inout arm_thread_state64_t) -> kern_return_t
typealias SpawnDrvExitHandler = (_: SpawnDrv, _: Int32) -> Void

class SpawnDrv {
    public let executable: URL
    
    public private(set) var pid: pid_t = 0
    public private(set) var child: Task!
    
    private var curPlat:  UInt64 = 0
    private var getEntry: UInt64 = 0
    private var curPlatReg: UInt8 = 0
    private var base: UInt64 = 0
    
    private var exitHandler: SpawnDrvExitHandler?
    
    public init(executable: URL) {
        self.executable = executable
    }
    
    public func onExit(_ hndlr: @escaping SpawnDrvExitHandler) {
        exitHandler = hndlr
    }
    
    public func launch(arguments: [String], checkinData: DKCheckinData, exceptionHandler: @escaping SpawnDrvExceptionHandler) throws {
        var killChild = false
        defer {
            if killChild {
                kill(pid, SIGKILL)
            }
        }
        
        // Verify "driver"
        var entryPoint: UInt64!
        do {
            let drvMachO = try MachO(fromFile: executable.path)
            
            for lc in drvMachO.cmds {
                if case .Unknown(0x13371337) = lc.type,
                   (lc.cmdSize + 8) >= MemoryLayout<entry_point_command>.size {
                    // This is the LC_MAIN command
                    let ep = lc as! OpaqueLoadCommand
                    let epData = Data(repeating: 0, count: 8) + ep.data
                    entryPoint = epData.withUnsafeBytes { (ptr: UnsafeRawBufferPointer) in
                        ptr.baseAddress!.assumingMemoryBound(to: entry_point_command.self).pointee.entryoff
                    }
                    
                    break
                }
            }
        } catch {
            throw SpawnDriverError.failedToOpenDriver
        }

        if entryPoint == nil {
            throw SpawnDriverError.notADriver
        }

        var attr: posix_spawnattr_t?

        guard posix_spawnattr_init(&attr) == 0 else {
            throw SpawnDriverError.posix_spawnattr_initFailed
        }

        posix_spawnattr_setprocesstype_np(&attr, POSIX_SPAWN_PROC_TYPE_DRIVER)

        // Drivers must be sandboxed -> Use a built-in sandbox
        // It shouldn't be too restrictive
        var sbattr = sandbox_spawnattrs()
        sandbox_spawnattrs_init(&sbattr)
        sandbox_spawnattrs_setprofilename(&sbattr, "debugserver")
        posix_spawnattr_setmacpolicyinfo_np(&attr, "Sandbox", &sbattr, 1104)

        posix_spawnattr_setflags(&attr, Int16(POSIX_SPAWN_START_SUSPENDED))
        
        // Clone our logging pipe to stdout/stderr
        var fileActions: posix_spawn_file_actions_t?
        posix_spawn_file_actions_init(&fileActions)
        if let log = Logger.logFileHandle {
            posix_spawn_file_actions_adddup2(&fileActions, log.fileDescriptor, STDOUT_FILENO)
            posix_spawn_file_actions_adddup2(&fileActions, log.fileDescriptor, STDERR_FILENO)
        }

        var cArgs: [UnsafeMutablePointer<CChar>?] = [strdup(executable.path)]
        for arg in arguments {
            cArgs.append(strdup(arg))
        }
        
        cArgs.append(nil)
        
        defer {
            for cArg in cArgs {
                free(cArg)
            }
        }
        
        guard posix_spawnp(&pid, executable.path, &fileActions, &attr, cArgs, environ) == 0 else {
            let err = errno
            throw SpawnDriverError.posix_spawnFailed(error: err, string: String(cString: strerror(err)))
        }
        
        // Force child to be killed if anything unexpected happens now
        killChild = true

        guard let child = Task.forPID(pid) else {
            throw SpawnDriverError.task_for_pidFailed
        }
        
        self.child = child

        // Need to set breakpoints and patch some stuff
        // Get current state first
        let th = child.threads[0]

        try setupDYLDPatch()

        Logger.print("[SpawnDrv] Patches set-up")

        // Make sure we are the exception server
        var excPort: mach_port_t = 0
        guard mach_port_allocate(mach_task_self_, MACH_PORT_RIGHT_RECEIVE, &excPort) == KERN_SUCCESS else {
            throw SpawnDriverError.mach_port_allocateFailed
        }

        guard mach_port_insert_right(mach_task_self_, excPort, excPort, mach_msg_type_name_t(MACH_MSG_TYPE_MAKE_SEND)) == KERN_SUCCESS else {
            throw SpawnDriverError.mach_port_insert_rightFailed
        }

        guard task_set_exception_ports(child.tp, exception_mask_t(EXC_MASK_BREAKPOINT | EXC_MASK_BAD_ACCESS), excPort, EXCEPTION_DEFAULT, 0) == KERN_SUCCESS else {
            throw SpawnDriverError.task_set_exception_portsFailed
        }

        Logger.print("[SpawnDrv] Resuming!")

        kill(pid, SIGCONT)

        DispatchQueue.init(label: "Fugu15_ExceptionServer").async {
            let buffer = malloc(1024)!
            while true {
                let hdr = buffer.assumingMemoryBound(to: mach_msg_header_t.self)
                hdr.pointee.msgh_local_port = excPort
                hdr.pointee.msgh_size = 1024
                
                guard mach_msg_receive(hdr) == KERN_SUCCESS else {
                    Logger.print("[SpawnDrv] Failed to receive exception message!")
                    kill(self.pid, SIGKILL)
                    return
                }
                
                Logger.print("[SpawnDrv] Received exception message!")
                
                var kr: kern_return_t = 0
                do {
                    kr = try self.handleException(thread: th, entryPoint: entryPoint, checkinData: checkinData, exceptionHandler: exceptionHandler)
                } catch let e {
                    Logger.print("[SpawnDrv] Exception while handling exception: \(e)")
                    kill(self.pid, SIGKILL)
                    return
                }
                
                let reply = buffer.assumingMemoryBound(to: exception_message_reply.self)
                
                // Send reply
                reply.pointee.hdr.msgh_bits          = mach_msg_bits_t(MACH_MSG_TYPE_MOVE_SEND_ONCE)
                reply.pointee.hdr.msgh_size          = 36
                reply.pointee.hdr.msgh_local_port    = 0
                reply.pointee.hdr.msgh_voucher_port  = 0
                reply.pointee.hdr.msgh_id           += 100
                
                reply.pointee.NDR = NDR_record
                
                reply.pointee.result = kr
                
                guard mach_msg_send(hdr) == KERN_SUCCESS else {
                    Logger.print("[SpawnDrv] Failed to send exception message reply!")
                    kill(self.pid, SIGKILL)
                    return
                }
                
                if kr != KERN_SUCCESS {
                    Logger.print("[SpawnDrv] Exception handler failed!")
                    kill(self.pid, SIGKILL)
                    return
                }
            }
        }
        
        DispatchQueue.init(label: "Fugu15_ExitHandler").async {
            var status: Int32 = 0
            waitpid(self.pid, &status, 0)
            
            self.exitHandler?(self, status)
        }
        
        // Child should continue to live after we return
        killChild = false
    }
    
    private func setupDYLDPatch() throws {
        let th = child.threads[0]
        
        guard let dyld = try? MachO(fromFile: "/usr/lib/dyld") else {
            throw DyldPatchSetupError.failedToOpenDyld
        }
        
        var entry: UInt64!
        for cmd in dyld.cmds {
            if let uCmd = cmd as? UnixThreadLoadCommand {
                guard let state = uCmd.threadStates[0].state.tryGetGeneric(type: arm_thread_state64_t.self) else {
                    throw DyldPatchSetupError.badDyldThreadState
                }
                
                #if arch(arm64) && __DARWIN_OPAQUE_ARM_THREAD_STATE64
                entry = UInt64(UInt(bitPattern: state.__opaque_pc))
                #else
                entry = state.__pc
                #endif
                break
            }
        }
        
        guard let entry = entry else {
            throw DyldPatchSetupError.noDyldEntryPoint
        }
        
        guard let getEntryFunc = (try? dyld.getSymbolTable())?.symbol(forName: "__ZNK5dyld313MachOAnalyzer8getEntryERyRb")?.value else {
            throw DyldPatchSetupError.noDyld3MachOAnalyzerGetEntry
        }
        
        guard let textSegment = dyld.pfSegment(forName: "__TEXT") else {
            throw DyldPatchSetupError.noDyldTextSegment
        }
        
        var getEntryXref: UInt64?
        var curAddr: UInt64?
        
    outer:
        while let xref = textSegment.findNextXref(to: getEntryFunc, startAt: curAddr) {
            for i in 1..<20 {
                let pc = xref - UInt64(i * 4)
                let instr = textSegment.instruction(at: pc) ?? 0
                if let args = AArch64Instr.Args.cmp(instr) {
                    if args.isImm && args.shift == 0 && args.immOrRegB == 0xA {
                        // Found it
                        getEntryXref = pc - 4
                        curPlatReg = args.regA
                        break outer
                    }
                }
            }
            
            curAddr = xref + 4
        }
        
        guard let curPlatCheck = getEntryXref else {
            throw DyldPatchSetupError.noDyldCurrentPlatformCheck
        }
        
        Logger.fmt("CP: %p", curPlatCheck)
        Logger.fmt("GE: %p", getEntryFunc)
        
        guard var state: arm_thread_state64_t = th.getState(type: ARM_THREAD_STATE64) else {
            throw DyldPatchSetupError.failedToGetThreadState
        }
        
        guard var dbgState: arm_debug_state64_t = th.getState(type: ARM_DEBUG_STATE64) else {
            throw DyldPatchSetupError.failedToGetThreadDebugState
        }
        
        base = thread_state64_get_pc(&state) &- entry
        
        curPlat  = base &+ curPlatCheck
        getEntry = base &+ getEntryFunc
        
        dbgState.__bcr.0 = BP_BAS | BP_USER | BP_ENABLED
        dbgState.__bvr.0 = curPlat
        
        dbgState.__bcr.1 = BP_BAS | BP_USER | BP_ENABLED
        dbgState.__bvr.1 = getEntry
        
        guard th.setState(type: ARM_DEBUG_STATE64, state: dbgState) else {
            throw DyldPatchSetupError.failedToSetThreadDebugState
        }
    }
    
    private func handleException(thread th: Thread, entryPoint: UInt64, checkinData: DKCheckinData, exceptionHandler: SpawnDrvExceptionHandler) throws -> kern_return_t {
        guard var state: arm_thread_state64_t = th.getState(type: ARM_THREAD_STATE64) else {
            throw HandleExceptionError.failedToGetThreadState
        }
        
        let pc = thread_state64_get_pc(&state)
        let lr = thread_state64_get_lr(&state)
        
        Logger.fmt("Exception occured @ %p [%p]", pc, pc &- base)
        Logger.fmt("LR: %p [%p]", lr, lr &- base)
        
        if pc == curPlat {
            // Why is state.__x not an array?!
            withUnsafeMutablePointer(to: &state.__x.0) { ptr in
                ptr[Int(curPlatReg)] = 0
            }
            
            thread_state64_set_pc(&state, pc + 4)
        } else if pc == getEntry {
            child.w64(state.__x.1, entryPoint)
            child.w8(state.__x.2, 0)
            
            state.__x.0 = 1
            
            thread_state64_set_pc(&state, lr)
            
        // SpawnDrv also provides some magic functions
        } else if pc == 0x4142434400 {
            // Send token and tag
            var token = mach_port_t.max
            for i in 0..<mach_port_t.max {
                // Why is there no proper API to inject a mach port into another process?
                if mach_port_insert_right(child.tp, i, checkinData.token, mach_msg_type_name_t(MACH_MSG_TYPE_COPY_SEND)) == KERN_SUCCESS {
                    token = i
                    break
                }
            }
            
            child.w64(state.__x.0, UInt64(token))
            child.w64(state.__x.1, checkinData.tag)
            
            thread_state64_set_pc(&state, lr)
        } else if pc == 0x4142434408 {
            state.__x.0 = UInt64(getPCIMemorySize())
            thread_state64_set_pc(&state, lr)
        }
        else {
            let kr = exceptionHandler(self, child, th, &state)
            guard kr == KERN_SUCCESS else {
                Logger.print("\(state)")
                Logger.print("\(state.__x.0)")
                Logger.print("\(child.r32(pc))")
                Logger.print("OOPS")
                return kr
            }
        }
        
        guard th.setState(type: ARM_THREAD_STATE64, state: state) else {
            throw HandleExceptionError.failedToSetThreadState
        }
        
        return KERN_SUCCESS
    }
    
    public enum DyldPatchSetupError: Error {
        case failedToOpenDyld
        case badDyldThreadState
        case noDyldEntryPoint
        case noDyld3MachOAnalyzerGetEntry
        case noDyldTextSegment
        case noDyldCurrentPlatformCheck
        case failedToGetThreadState
        case failedToGetThreadDebugState
        case failedToSetThreadDebugState
    }

    public enum HandleExceptionError: Error {
        case failedToGetThreadState
        case failedToSetThreadState
    }
}
