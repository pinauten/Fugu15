#include <fcntl.h>
#import <Foundation/Foundation.h>

#import <mach-o/getsect.h>
#import <mach-o/dyld.h>
#import <mach/mach.h>
#import <mach-o/loader.h>
#import <mach-o/nlist.h>
#import <mach-o/reloc.h>
#import <mach-o/dyld_images.h>
#import <mach-o/fat.h>

#ifdef __LP64__
#define segment_command_universal segment_command_64
#define mach_header_universal mach_header_64
#define MH_MAGIC_UNIVERSAL MH_MAGIC_64
#define MH_CIGAM_UNIVERSAL MH_CIGAM_64
#else
#define segment_command_universal segment_command
#define mach_header_universal mach_header
#define MH_MAGIC_UNIVERSAL MH_MAGIC
#define MH_CIGAM_UNIVERSAL MH_CIGAM
#endif

#define SWAP32(x) ((((x) & 0xff000000) >> 24) | (((x) & 0xff0000) >> 8) | (((x) & 0xff00) << 8) | (((x) & 0xff) << 24))
uint32_t s32(uint32_t toSwap, BOOL shouldSwap)
{
    return shouldSwap ? SWAP32(toSwap) : toSwap;
}

void getCSBlobOffsetAndSize(NSString* filePath, uint32_t* outOffset, uint32_t* outSize)
{
    FILE* binaryFile = fopen(filePath.UTF8String, "rb");
    struct mach_header_universal header;
    fread(&header,sizeof(header),1,binaryFile);

#if __arm64e__
    uint32_t subtypeToSearch = CPU_SUBTYPE_ARM64E_NEW_ABI;
#else
    uint32_t subtypeToSearch = 0;
#endif

    // get arch offset
    uint32_t archOffset = 0;
    if(header.magic == FAT_MAGIC || header.magic == FAT_CIGAM)
    {
        fseek(binaryFile,0,SEEK_SET);

        struct fat_header fatHeader;
        fread(&fatHeader,sizeof(fatHeader),1,binaryFile);

        BOOL swpFat = fatHeader.magic == FAT_CIGAM;

        for(int i = 0; i < s32(fatHeader.nfat_arch, swpFat); i++)
        {
            struct fat_arch fatArch;
            fseek(binaryFile,sizeof(fatHeader) + sizeof(fatArch) * i,SEEK_SET);
            fread(&fatArch,sizeof(fatArch),1,binaryFile);

            if(s32(fatArch.cputype, swpFat) != CPU_TYPE_ARM64 || s32(fatArch.cpusubtype, swpFat) != subtypeToSearch)
            {
                continue;
            }

            archOffset = s32(fatArch.offset, swpFat);
            break;
        }
    }

    // get blob offset
    fseek(binaryFile,archOffset,SEEK_SET);
    fread(&header,sizeof(header),1,binaryFile);

    BOOL swp = header.magic == MH_CIGAM_UNIVERSAL;

    uint32_t offset = archOffset + sizeof(header);
    for(int c = 0; c < s32(header.ncmds, swp); c++)
    {
        fseek(binaryFile,offset,SEEK_SET);
        struct load_command cmd;
        fread(&cmd,sizeof(cmd),1,binaryFile);
        uint32_t normalizedCmd = s32(cmd.cmd,swp);
        if(normalizedCmd == LC_CODE_SIGNATURE)
        {
            struct linkedit_data_command codeSignCommand;
            fseek(binaryFile,offset,SEEK_SET);
            fread(&codeSignCommand,sizeof(codeSignCommand),1,binaryFile);
            if(outOffset) *outOffset = archOffset + codeSignCommand.dataoff;
            if(outSize) *outSize = archOffset + codeSignCommand.datasize;
            break;
        }

        offset += cmd.cmdsize;
    }
    
    fclose(binaryFile);
}

int loadEmbeddedSignature(NSString* filePath)
{
    uint32_t offset = 0, size = 0;
    
    getCSBlobOffsetAndSize(filePath, &offset, &size);
    
    int binaryFd = open(filePath.fileSystemRepresentation, O_RDONLY);
    if (binaryFd < 0) {
        NSLog(@"loadEmbeddedSignature error: Failed to open %@", filePath);
        return 1;
    }
    
    struct fsignatures fsig;
    fsig.fs_file_start = 0;
    fsig.fs_blob_start = (void*)(uint64_t)offset;
    fsig.fs_blob_size = size;
    
    int ret = fcntl(binaryFd, F_ADDFILESIGS, fsig);
    close(binaryFd);
    return ret;
}